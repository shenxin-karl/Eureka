#include "DXCShader.h"

#include <format>

namespace dx12lib {

auto DXCShader::getByteCode() const -> D3D12_SHADER_BYTECODE {
	if (_pByteCode == nullptr)
		return { nullptr, 0 };
	return { _pByteCode->GetBufferPointer(), _pByteCode->GetBufferSize() };
}

struct DXCInclude : public IDxcIncludeHandler {
    ULONG STDMETHODCALLTYPE AddRef(void) final {
	    return 0;
    }
    ULONG STDMETHODCALLTYPE Release(void) final {
		return 0;   
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) final {
        ppvObject = nullptr;
        return E_FAIL;
    }

	HRESULT STDMETHODCALLTYPE LoadSource(
        _In_z_ LPCWSTR pFilename,                                 // Candidate filename.
        _COM_Outptr_result_maybenull_ IDxcBlob **ppIncludeSource  // Resultant source object for included file, nullptr if not found.
    ) override
	{
        UINT bytes = 0;
        LPCVOID pData = nullptr;
        std::string fileName = to_string(pFilename);
		auto hr = pInclude->Open(D3D_INCLUDE_LOCAL, fileName.c_str(), nullptr, &pData, &bytes);
        if (pData == nullptr) {
	        ppIncludeSource = nullptr;
            return hr;
        }

        WRL::ComPtr<IDxcBlobEncoding> pSource;
        pUtils->CreateBlob(pData, bytes, DXC_CP_ACP, &pSource);
        *ppIncludeSource = pSource.Detach();
        return hr;
	}
public:
    WRL::ComPtr<IDxcUtils> pUtils;
    ID3DInclude *pInclude;
};

void DXCShader::compileFormMemory(const CompileFormMemoryArgs &args) {
    WRL::ComPtr<IDxcUtils> pUtils;
    WRL::ComPtr<IDxcCompiler3> pCompiler;
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

    std::wstring filename = to_wstring(args.fileName);
    std::wstring target = to_wstring(args.target);
    std::wstring entryPoint = to_wstring(args.entryPoint);

    std::vector<std::wstring> compileFlags = {
        filename.c_str(),            // Optional shader source file name for error reporting and for PIX shader source view.  
        L"-E", entryPoint.c_str(),   // Entry point.
        L"-T", target.c_str(),       // Target.
        L"-Zi",                      // Enable debug information.
        L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
        L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
        L"-Qstrip_rootsignature",
    	L"-nologo",
    };

#if defined(DEBUG) || defined(_DEBUG) 
    args.push_back(L"-Od");
#endif

    while (args.pMacro != nullptr) {
	    if (args.pMacro->Name == nullptr && args.pMacro->Definition == nullptr)
            break;
        auto flag = std::format("-D%s=%s", args.pMacro->Name, args.pMacro->Definition);
        compileFlags.push_back(to_wstring(flag));
    }

    std::vector<LPCWCHAR> pszArgs(compileFlags.size());
    for (size_t i = 0; i < compileFlags.size(); ++i)
        pszArgs.push_back(compileFlags[i].c_str());

    IDxcIncludeHandler *pIncludeHandler;
    WRL::ComPtr<IDxcIncludeHandler> pIncludeHandleCom;
    std::unique_ptr<DXCInclude> pDxcInclude;
    if (args.pInclude == D3D_COMPILE_STANDARD_FILE_INCLUDE) {
        pUtils->CreateDefaultIncludeHandler(&pIncludeHandleCom);
        pIncludeHandler = pIncludeHandleCom.Get();
    } else {
        pDxcInclude = std::make_unique<DXCInclude>();
        pDxcInclude->pUtils = pUtils;
        pDxcInclude->pInclude = args.pInclude;
        pIncludeHandler = pDxcInclude.get();
	}

    DxcBuffer source;
    source.Ptr = args.pData;
    source.Size = args.sizeInByte;
    source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.
    WRL::ComPtr<IDxcResult> pResults;
    pCompiler->Compile(
        &source,                // Source buffer.
        pszArgs.data(),         // Array of pointers to arguments.
        pszArgs.size(),         // Number of arguments.
        pIncludeHandler,        // User-provided interface to handle #include directives (optional).
        IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
    );

    HRESULT hrStatus;
    pResults->GetStatus(&hrStatus);
	ThrowIfFailed(hrStatus);

    WRL::ComPtr<IDxcBlob> pReflectionData;
    pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
    if (pReflectionData != nullptr) {
        DxcBuffer reflectionData;
        reflectionData.Encoding = DXC_CP_ACP;
        reflectionData.Ptr = pReflectionData->GetBufferPointer();
        reflectionData.Size = pReflectionData->GetBufferSize();
        pUtils->CreateReflection(&reflectionData, IID_PPV_ARGS(&_pShaderReflection));
    }
}

void DXCShader::makeFromByteCode(const void *pData, size_t sizeInByte) {
    WRL::ComPtr<IDxcUtils> pUtils;
    WRL::ComPtr<IDxcCompiler3> pCompiler;
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

    WRL::ComPtr<IDxcBlobEncoding> pBlob;
    pUtils->CreateBlob(pData, sizeInByte, DXC_CP_ACP, &pBlob);
    _pByteCode = pBlob.Detach();

    WRL::ComPtr<IDxcResult> pResults;
    DxcBuffer source;
    source.Ptr = pData;
    source.Size = sizeInByte;
    source.Encoding = DXC_CP_ACP; 
    pCompiler->Disassemble(&source, IID_PPV_ARGS(&pResults));

    WRL::ComPtr<IDxcBlob> pReflectionData;
    pResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
    if (pReflectionData != nullptr) {
        DxcBuffer ReflectionData;
        ReflectionData.Encoding = DXC_CP_ACP;
        ReflectionData.Ptr = pReflectionData->GetBufferPointer();
        ReflectionData.Size = pReflectionData->GetBufferSize();
        pUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(&_pShaderReflection));
    } else {
	    _pShaderReflection = nullptr;
    }
}

}
